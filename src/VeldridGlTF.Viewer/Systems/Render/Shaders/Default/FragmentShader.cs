// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace VeldridGlTF.Viewer.Systems.Render.Shaders.Default
{
    /// <summary>
    ///     Class to produce the template output
    /// </summary>
#line 1 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"
    [GeneratedCode("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class FragmentShader : FragmentShaderBase
    {
        /// <summary>
        ///     Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            Write(@"#version 450

struct MaterialPropertiesInfo
{
    vec4 BaseColor;
};

struct MaterialInfo
{
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    vec3 reflectance0;            // full reflectance color (normal incidence angle)

    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting

    vec3 reflectance90;           // reflectance color at grazing angle
    vec3 specularColor;           // color contribution from specular lighting
};

layout(set = 0, binding = 1) uniform texture2D brdfLUTTexture;
layout(set = 0, binding = 2) uniform sampler brdfLUTSampler;

layout(set = 1, binding = 0) uniform textureCube ReflectionTexture;
layout(set = 1, binding = 1) uniform sampler ReflectionSampler;

layout(set = 3, binding = 0) uniform MaterialProperties
{
    MaterialPropertiesInfo _MaterialProperties;
};
layout(set = 3, binding = 1) uniform texture2D SurfaceTexture;
layout(set = 3, binding = 2) uniform sampler SurfaceSampler;

");

#line 38 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"

            for (var location = 0; location < Context.Varyings.Count; ++location)
                WriteLine(string.Format("layout(location = {0}) in {1} {2};", Context.Varyings[location].Location,
                    Glsl.NameOf(Context.Varyings[location].Format), Context.Varyings[location].Name));


#line default
#line hidden
            Write("layout(location = 0) out vec4 fsout_color;\r\n\r\nconst float GAMMA = 2.2;\r\nconst flo" +
                  "at INV_GAMMA = 1.0 / GAMMA;\r\n\r\n// linear to sRGB approximation\r\n// see http://ch" +
                  "illiant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\r\nvec3 LINEARtoSRG" +
                  "B(vec3 color)\r\n{\r\n    return pow(color, vec3(INV_GAMMA));\r\n}\r\n\r\n// sRGB to linea" +
                  "r approximation\r\n// see http://chilliant.blogspot.com/2012/08/srgb-approximation" +
                  "s-for-hlsl.html\r\nvec4 SRGBtoLINEAR(vec4 srgbIn)\r\n{\r\n    return vec4(pow(srgbIn.x" +
                  "yz, vec3(GAMMA)), srgbIn.w);\r\n}\r\n\r\nvec3 getIBLContribution(MaterialInfo material" +
                  "Info, vec3 n, vec3 v)\r\n{\r\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\r\n\tint u_" +
                  "MipCount = 5;\r\n\r\n    float lod = clamp(materialInfo.perceptualRoughness * float(" +
                  "u_MipCount), 0.0, float(u_MipCount));\r\n    vec3 reflection = normalize(reflect(-" +
                  "v, n));\r\n\r\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualR" +
                  "oughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\r\n    vec2 brdf = texture(sampler2D(B" +
                  "RDFTexture, BRDFSampler), brdfSamplePoint).rg;\r\n\r\n    vec4 diffuseSample =  text" +
                  "ureLod(samplerCube(ReflectionTexture, ReflectionSampler), n, 5.0f);\r\n\r\n    vec4 " +
                  "specularSample = textureLod(samplerCube(ReflectionTexture, ReflectionSampler), r" +
                  "eflection, lod);\r\n\r\n    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\r\n  " +
                  "  vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;\r\n\r\n    vec3 diffuse = d" +
                  "iffuseLight * materialInfo.diffuseColor;\r\n    vec3 specular = specularLight * (m" +
                  "aterialInfo.specularColor * brdf.x + brdf.y);\r\n\r\n    return diffuse + specular;\r" +
                  "\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec3 normal = vec3(0.0,1.0,0.0);\r\n\tfloat perceptualRoug" +
                  "hness = 1.0;\r\n    float metallic = 0.0;\r\n    vec4 baseColor = vec4(0.0, 0.0, 0.0" +
                  ", 1.0);\r\n    vec3 diffuseColor = vec3(0.0);\r\n    vec3 specularColor= vec3(0.3);\r" +
                  "\n\tvec3 f0 = vec3(0.04);\r\n");

#line 97 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"


            if (Context.Normal != null)
                WriteLine("normal = normalize({0});", Context.Normal.Name);
            else if (Context.TBN != null) WriteLine("normal = normalize({0}[2]);", Context.TBN.Name);


#line default
#line hidden

#line 108 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"

            if (Context.IsFlagSet(ShaderFlag.HAS_DIFFUSE_MAP) && Context.TexCoord0 != null)
            {
#line default
#line hidden
                Write("\tbaseColor = texture(sampler2D(SurfaceTexture, SurfaceSampler),");

#line 112 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"
                Write(ToStringHelper.ToStringWithCulture(Context.TexCoord0));

#line default
#line hidden
                Write(");\r\n");

#line 113 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"
            }
            else
            {
#line default
#line hidden
                Write("\tbaseColor = _MaterialProperties.BaseColor;\r\n");

#line 119 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"
            }


#line default
#line hidden
            Write(@"    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);

    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    vec3 specularEnvironmentR0 = specularColor.rgb;
    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to ""Real-Time-Rendering"" 4th editon on page 325.
    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));

	MaterialInfo materialInfo = MaterialInfo(
        perceptualRoughness,
        specularEnvironmentR0,
        alphaRoughness,
        diffuseColor,
        specularEnvironmentR90,
        specularColor
    );
	vec3 color = vec3(0.0, 0.0, 0.0);
    color += getIBLContribution(materialInfo, normal, ");

#line 147 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"
            Write(ToStringHelper.ToStringWithCulture(Context.CameraPosition));

#line default
#line hidden
            Write("-");

#line 147 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\Default\FragmentShader.tt"
            Write(ToStringHelper.ToStringWithCulture(Context.WorldPosition));

#line default
#line hidden
            Write(");\r\n\tfsout_color = vec4(color,baseColor.a);\r\n\t//fsout_color = vec4(normal.x * 0.5" +
                  " + 0.5, normal.y * 0.5 + 0.5, normal.z * 0.5 + 0.5, 1.0);\r\n\t\r\n}");
            return GenerationEnvironment.ToString();
        }
    }

#line default
#line hidden

    #region Base class

    /// <summary>
    ///     Base class for this transformation
    /// </summary>
    [GeneratedCode("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public class FragmentShaderBase
    {
        #region Fields

        private StringBuilder generationEnvironmentField;
        private CompilerErrorCollection errorsField;
        private List<int> indentLengthsField;
        private bool endsWithNewline;

        #endregion

        #region Properties

        /// <summary>
        ///     The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected StringBuilder GenerationEnvironment
        {
            get
            {
                if (generationEnvironmentField == null) generationEnvironmentField = new StringBuilder();
                return generationEnvironmentField;
            }
            set => generationEnvironmentField = value;
        }

        /// <summary>
        ///     The error collection for the generation process
        /// </summary>
        public CompilerErrorCollection Errors
        {
            get
            {
                if (errorsField == null) errorsField = new CompilerErrorCollection();
                return errorsField;
            }
        }

        /// <summary>
        ///     A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private List<int> indentLengths
        {
            get
            {
                if (indentLengthsField == null) indentLengthsField = new List<int>();
                return indentLengthsField;
            }
        }

        /// <summary>
        ///     Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent { get; private set; } = "";

        /// <summary>
        ///     Current transformation session
        /// </summary>
        public virtual IDictionary<string, object> Session { get; set; }

        #endregion

        #region Transform-time helpers

        /// <summary>
        ///     Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend)) return;
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (GenerationEnvironment.Length == 0
                || endsWithNewline)
            {
                GenerationEnvironment.Append(CurrentIndent);
                endsWithNewline = false;
            }

            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(Environment.NewLine, StringComparison.CurrentCulture)) endsWithNewline = true;
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if (CurrentIndent.Length == 0)
            {
                GenerationEnvironment.Append(textToAppend);
                return;
            }

            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(Environment.NewLine, Environment.NewLine + CurrentIndent);
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (endsWithNewline)
                GenerationEnvironment.Append(textToAppend, 0, textToAppend.Length - CurrentIndent.Length);
            else
                GenerationEnvironment.Append(textToAppend);
        }

        /// <summary>
        ///     Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            Write(textToAppend);
            GenerationEnvironment.AppendLine();
            endsWithNewline = true;
        }

        /// <summary>
        ///     Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            Write(string.Format(CultureInfo.CurrentCulture, format, args));
        }

        /// <summary>
        ///     Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            WriteLine(string.Format(CultureInfo.CurrentCulture, format, args));
        }

        /// <summary>
        ///     Raise an error
        /// </summary>
        public void Error(string message)
        {
            var error = new CompilerError();
            error.ErrorText = message;
            Errors.Add(error);
        }

        /// <summary>
        ///     Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            var error = new CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            Errors.Add(error);
        }

        /// <summary>
        ///     Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if (indent == null) throw new ArgumentNullException("indent");
            CurrentIndent = CurrentIndent + indent;
            indentLengths.Add(indent.Length);
        }

        /// <summary>
        ///     Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            var returnValue = "";
            if (indentLengths.Count > 0)
            {
                var indentLength = indentLengths[indentLengths.Count - 1];
                indentLengths.RemoveAt(indentLengths.Count - 1);
                if (indentLength > 0)
                {
                    returnValue = CurrentIndent.Substring(CurrentIndent.Length - indentLength);
                    CurrentIndent = CurrentIndent.Remove(CurrentIndent.Length - indentLength);
                }
            }

            return returnValue;
        }

        /// <summary>
        ///     Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            indentLengths.Clear();
            CurrentIndent = "";
        }

        #endregion

        #region ToString Helpers

        /// <summary>
        ///     Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private IFormatProvider formatProviderField = CultureInfo.InvariantCulture;

            /// <summary>
            ///     Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public IFormatProvider FormatProvider
            {
                get => formatProviderField;
                set
                {
                    if (value != null) formatProviderField = value;
                }
            }

            /// <summary>
            ///     This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if (objectToConvert == null) throw new ArgumentNullException("objectToConvert");
                var t = objectToConvert.GetType();
                var method = t.GetMethod("ToString", new[]
                {
                    typeof(IFormatProvider)
                });
                if (method == null)
                    return objectToConvert.ToString();
                return (string) method.Invoke(objectToConvert, new object[]
                {
                    formatProviderField
                });
            }
        }

        /// <summary>
        ///     Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper { get; } = new ToStringInstanceHelper();

        #endregion
    }

    #endregion
}