// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace VeldridGlTF.Viewer.Systems.Render.Shaders.PBR
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\PBR\FragmentShader.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class FragmentShader : FragmentShaderBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write(@"#version 450

//
// This fragment shader defines a reference implementation for Physically Based Shading of
// a microfacet surface material defined by a glTF model.
//
// References:
// [1] Real Shading in Unreal Engine 4
//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
// [2] Physically Based Shading at Disney
//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf
// [3] README.md - Environment Maps
//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps
// [4] ""An Inexpensive BRDF Model for Physically based Rendering"" by Christophe Schlick
//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf

");
            
            #line 22 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\PBR\FragmentShader.tt"

	WriteDefines();

            
            #line default
            #line hidden
            this.Write("\r\n");
            
            #line 26 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\PBR\FragmentShader.tt"

	for (int location=0; location<Context.Varyings.Count; ++location)
	{
		WriteLine(string.Format("layout(location = {0}) in {1} {2};", Context.Varyings[location].Location, Glsl.NameOf(Context.Varyings[location].Format), Context.Varyings[location].Name));
	}

            
            #line default
            #line hidden
            this.Write("layout(set = 0, binding = 0) uniform EnvironmentProperties\r\n{\r\n");
            
            #line 34 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\PBR\FragmentShader.tt"

	WriteMembers<EnvironmentProperties>();

            
            #line default
            #line hidden
            this.Write("};\r\nlayout (location=0) out vec4 outFragColor;\r\n\r\n#ifdef USE_TEX_LOD\r\n#extension " +
                    "GL_EXT_shader_texture_lod: enable\r\n#endif\r\n\r\n#extension GL_OES_standard_derivati" +
                    "ves : enable\r\n\r\n#ifdef USE_HDR\r\n#extension GL_OES_texture_float : enable\r\n#exten" +
                    "sion GL_OES_texture_float_linear : enable\r\n#endif\r\n\r\nprecision highp float;\r\n\r\nc" +
                    "onst float GAMMA = 2.2;\r\nconst float INV_GAMMA = 1.0 / GAMMA;\r\n\r\n// linear to sR" +
                    "GB approximation\r\n// see http://chilliant.blogspot.com/2012/08/srgb-approximatio" +
                    "ns-for-hlsl.html\r\nvec3 LINEARtoSRGB(vec3 color)\r\n{\r\n    return pow(color, vec3(I" +
                    "NV_GAMMA));\r\n}\r\n\r\n// sRGB to linear approximation\r\n// see http://chilliant.blogs" +
                    "pot.com/2012/08/srgb-approximations-for-hlsl.html\r\nvec4 SRGBtoLINEAR(vec4 srgbIn" +
                    ")\r\n{\r\n    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);\r\n}\r\n\r\n// Uncharte" +
                    "d 2 tone map\r\n// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/" +
                    "\r\nvec3 toneMapUncharted2Impl(vec3 color)\r\n{\r\n    const float A = 0.15;\r\n    cons" +
                    "t float B = 0.50;\r\n    const float C = 0.10;\r\n    const float D = 0.20;\r\n    con" +
                    "st float E = 0.02;\r\n    const float F = 0.30;\r\n    return ((color*(A*color+C*B)+" +
                    "D*E)/(color*(A*color+B)+D*F))-E/F;\r\n}\r\n\r\nvec3 toneMapUncharted(vec3 color)\r\n{\r\n " +
                    "   const float W = 11.2;\r\n    color = toneMapUncharted2Impl(color * 2.0);\r\n    v" +
                    "ec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));\r\n    return LINEARtoSRGB(" +
                    "color * whiteScale);\r\n}\r\n\r\n// Hejl Richard tone map\r\n// see: http://filmicworlds" +
                    ".com/blog/filmic-tonemapping-operators/\r\nvec3 toneMapHejlRichard(vec3 color)\r\n{\r" +
                    "\n    color = max(vec3(0.0), color - vec3(0.004));\r\n    return (color*(6.2*color+" +
                    ".5))/(color*(6.2*color+1.7)+0.06);\r\n}\r\n\r\n// ACES tone map\r\n// see: https://knark" +
                    "owicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\r\nvec3 toneMapACES" +
                    "(vec3 color)\r\n{\r\n    const float A = 2.51;\r\n    const float B = 0.03;\r\n    const" +
                    " float C = 2.43;\r\n    const float D = 0.59;\r\n    const float E = 0.14;\r\n    retu" +
                    "rn LINEARtoSRGB(clamp((color * (A * color + B)) / (color * (C * color + D) + E)," +
                    " 0.0, 1.0));\r\n}\r\n\r\nvec3 toneMap(vec3 color)\r\n{\r\n    color *= u_Exposure;\r\n\r\n#ifd" +
                    "ef TONEMAP_UNCHARTED\r\n    return toneMapUncharted(color);\r\n#endif\r\n\r\n#ifdef TONE" +
                    "MAP_HEJLRICHARD\r\n    return toneMapHejlRichard(color);\r\n#endif\r\n\r\n#ifdef TONEMAP" +
                    "_ACES\r\n    return toneMapACES(color);\r\n#endif\r\n\r\n    return LINEARtoSRGB(color);" +
                    "\r\n}\r\n\r\n\r\n// General Material\r\n#ifdef HAS_NORMAL_MAP\r\nlayout(set = 7, binding = 0" +
                    ") uniform texture2D NormalTexture;\r\nlayout(set = 7, binding = 1) uniform sampler" +
                    " NormalSampler;\r\nlayout(set = 7, binding = 2) uniform NormalMapProperties\r\n{\r\n");
            
            #line 137 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\PBR\FragmentShader.tt"

	WriteMembers<NormalMapProperties>();

            
            #line default
            #line hidden
            this.Write("};\r\n#endif\r\n\r\n#ifdef HAS_EMISSIVE_MAP\r\nlayout(set = 5, binding = 0) uniform textu" +
                    "re2D EmissiveTexture;\r\nlayout(set = 5, binding = 1) uniform sampler EmissiveSamp" +
                    "ler;\r\nlayout(set = 5, binding = 2) uniform EmissiveMapProperties\r\n{\r\n");
            
            #line 148 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\PBR\FragmentShader.tt"

	WriteMembers<EmissiveMapProperties>();

            
            #line default
            #line hidden
            this.Write("};\r\n\r\n#endif\r\n\r\n#ifdef MATERIAL_SPECULARGLOSSINESS\r\nlayout(set = 6, binding = 0) " +
                    "uniform SpecularGlossiness\r\n{\r\n");
            
            #line 158 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\PBR\FragmentShader.tt"

	WriteMembers<SpecularGlossiness>();

            
            #line default
            #line hidden
            this.Write(@"};

#endif
#ifdef HAS_DIFFUSE_MAP
layout(set = 6, binding = 1) uniform texture2D DiffuseTexture;
layout(set = 6, binding = 2) uniform sampler DiffuseSampler;
#endif
#ifdef HAS_SPECULAR_GLOSSINESS_MAP
layout(set = 6, binding = 3) uniform texture2D SpecularGlossinessTexture;
layout(set = 6, binding = 4) uniform sampler SpecularGlossinessSampler;
#endif

#ifdef MATERIAL_METALLICROUGHNESS
layout(set = 6, binding = 0) uniform MetallicRoughness
{
");
            
            #line 176 "E:\MyWork\VeldridGlTF\src\VeldridGlTF.Viewer\Systems\Render\Shaders\PBR\FragmentShader.tt"

	WriteMembers<MetallicRoughness>();

            
            #line default
            #line hidden
            this.Write("};\r\n\r\n#endif\r\n#ifdef HAS_BASE_COLOR_MAP\r\nlayout(set = 6, binding = 1) uniform tex" +
                    "ture2D BaseColorTexture;\r\nlayout(set = 6, binding = 2) uniform sampler BaseColor" +
                    "Sampler;\r\n#endif\r\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\r\nlayout(set = 6, binding = 3" +
                    ") uniform texture2D MetallicRoughnessTexture;\r\nlayout(set = 6, binding = 4) unif" +
                    "orm sampler MetallicRoughnessSampler;\r\n#endif\r\n\r\n#ifdef HAS_OCCLUSION_MAP\r\nunifo" +
                    "rm sampler2D u_OcclusionSampler;\r\nuniform int u_OcclusionUVSet;\r\nuniform float u" +
                    "_OcclusionStrength;\r\nuniform mat3 u_OcclusionUVTransform;\r\n#endif\r\n\r\n// IBL\r\n#if" +
                    "def USE_IBL\r\nlayout(set = 0, binding = 1) uniform texture2D brdfLUTTexture;\r\nlay" +
                    "out(set = 0, binding = 2) uniform sampler brdfLUTSampler;\r\n\r\nlayout(set = 1, bin" +
                    "ding = 0) uniform textureCube DiffuseEnvTexture;\r\nlayout(set = 1, binding = 1) u" +
                    "niform sampler DiffuseEnvSampler;\r\nlayout(set = 1, binding = 2) uniform textureC" +
                    "ube SpecularEnvTexture;\r\nlayout(set = 1, binding = 3) uniform sampler SpecularEn" +
                    "vSampler;\r\n#endif\r\n\r\nvec2 getNormalUV()\r\n{\r\n    vec3 uv = vec3(v_UVCoord1, 1.0);" +
                    "\r\n#ifdef HAS_NORMAL_MAP\r\n    uv.xy = NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\r" +
                    "\n    #ifdef HAS_NORMAL_UV_TRANSFORM\r\n    uv *= NormalUVTransform;\r\n    #endif\r\n#" +
                    "endif\r\n    return uv.xy;\r\n}\r\n\r\nvec2 getEmissiveUV()\r\n{\r\n    vec3 uv = vec3(v_UVC" +
                    "oord1, 1.0);\r\n#ifdef HAS_EMISSIVE_MAP\r\n    uv.xy = EmissiveUVSet < 1 ? v_UVCoord" +
                    "1 : v_UVCoord2;\r\n    #ifdef HAS_EMISSIVE_UV_TRANSFORM\r\n    uv *= EmissiveUVTrans" +
                    "form;\r\n    #endif\r\n#endif\r\n\r\n    return uv.xy;\r\n}\r\n\r\nvec2 getOcclusionUV()\r\n{\r\n " +
                    "   vec3 uv = vec3(v_UVCoord1, 1.0);\r\n#ifdef HAS_OCCLUSION_MAP\r\n    uv.xy = u_Occ" +
                    "lusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\r\n    #ifdef HAS_OCCLSION_UV_TRANSFORM" +
                    "\r\n    uv *= u_OcclusionUVTransform;\r\n    #endif\r\n#endif\r\n    return uv.xy;\r\n}\r\n\r" +
                    "\nvec2 getBaseColorUV()\r\n{\r\n    vec3 uv = vec3(v_UVCoord1, 1.0);\r\n#ifdef HAS_BASE" +
                    "_COLOR_MAP\r\n    uv.xy = BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\r\n    #ifde" +
                    "f HAS_BASECOLOR_UV_TRANSFORM\r\n    uv *= BaseColorUVTransform;\r\n    #endif\r\n#endi" +
                    "f\r\n    return uv.xy;\r\n}\r\n\r\nvec2 getMetallicRoughnessUV()\r\n{\r\n    vec3 uv = vec3(" +
                    "v_UVCoord1, 1.0);\r\n#ifdef HAS_METALLIC_ROUGHNESS_MAP\r\n    uv.xy = MetallicRoughn" +
                    "essUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\r\n    #ifdef HAS_METALLICROUGHNESS_UV_TRA" +
                    "NSFORM\r\n    uv *= MetallicRoughnessUVTransform;\r\n    #endif\r\n#endif\r\n    return " +
                    "uv.xy;\r\n}\r\n\r\nvec2 getSpecularGlossinessUV()\r\n{\r\n    vec3 uv = vec3(v_UVCoord1, 1" +
                    ".0);\r\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\r\n    uv.xy = SpecularGlossinessUVSet < " +
                    "1 ? v_UVCoord1 : v_UVCoord2;\r\n    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM\r\n  " +
                    "  uv *= SpecularGlossinessUVTransform;\r\n    #endif\r\n#endif\r\n    return uv.xy;\r\n}" +
                    "\r\n\r\nvec2 getDiffuseUV()\r\n{\r\n    vec3 uv = vec3(v_UVCoord1, 1.0);\r\n#ifdef HAS_DIF" +
                    "FUSE_MAP\r\n    uv.xy = DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;\r\n    #ifdef HA" +
                    "S_DIFFUSE_UV_TRANSFORM\r\n    uv *= DiffuseUVTransform;\r\n    #endif\r\n#endif\r\n    r" +
                    "eturn uv.xy;\r\n}\r\n\r\nconst float M_PI = 3.141592653589793;\r\nconst float c_MinRefle" +
                    "ctance = 0.04;\r\n\r\nstruct AngularInfo\r\n{\r\n    float NdotL;                  // co" +
                    "s angle between normal and light direction\r\n    float NdotV;                  //" +
                    " cos angle between normal and view direction\r\n    float NdotH;                  " +
                    "// cos angle between normal and half vector\r\n    float LdotH;                  /" +
                    "/ cos angle between light direction and half vector\r\n\r\n    float VdotH;         " +
                    "         // cos angle between view direction and half vector\r\n\r\n    vec3 padding" +
                    ";\r\n};\r\n\r\nvec4 getVertexColor()\r\n{\r\n   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\n" +
                    "#ifdef HAS_VERTEX_COLOR_VEC3\r\n    color.rgb = v_Color;\r\n#endif\r\n#ifdef HAS_VERTE" +
                    "X_COLOR_VEC4\r\n    color = v_Color;\r\n#endif\r\n\r\n   return color;\r\n}\r\n\r\n// Find the" +
                    " normal for this fragment, pulling either from a predefined normal map\r\n// or fr" +
                    "om the interpolated mesh normal and tangent attributes.\r\nvec3 getNormal()\r\n{\r\n  " +
                    "  vec2 UV = getNormalUV();\r\n\r\n    // Retrieve the tangent space matrix\r\n#ifndef " +
                    "HAS_TANGENTS\r\n    vec3 pos_dx = dFdx(v_Position);\r\n    vec3 pos_dy = dFdy(v_Posi" +
                    "tion);\r\n    vec3 tex_dx = dFdx(vec3(UV, 0.0));\r\n    vec3 tex_dy = dFdy(vec3(UV, " +
                    "0.0));\r\n    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_d" +
                    "y.t - tex_dy.s * tex_dx.t);\r\n\r\n#ifdef HAS_NORMALS\r\n    vec3 ng = normalize(v_Nor" +
                    "mal);\r\n#else\r\n    vec3 ng = cross(pos_dx, pos_dy);\r\n#endif\r\n\r\n    t = normalize(" +
                    "t - ng * dot(ng, t));\r\n    vec3 b = normalize(cross(ng, t));\r\n    mat3 tbn = mat" +
                    "3(t, b, ng);\r\n#else // HAS_TANGENTS\r\n    mat3 tbn = v_TBN;\r\n#endif\r\n\r\n#ifdef HAS" +
                    "_NORMAL_MAP\r\n    vec3 n = texture(sampler2D(NormalTexture, NormalSampler), UV).r" +
                    "gb;\r\n    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(NormalScale, NormalScale, 1" +
                    ".0)));\r\n#else\r\n    // The tbn matrix is linearly interpolated, so we need to re-" +
                    "normalize\r\n    vec3 n = normalize(tbn[2].xyz);\r\n#endif\r\n\r\n    return n;\r\n}\r\n\r\nfl" +
                    "oat getPerceivedBrightness(vec3 vector)\r\n{\r\n    return sqrt(0.299 * vector.r * v" +
                    "ector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);\r\n}\r\n\r\n// h" +
                    "ttps://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_mater" +
                    "ials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilit" +
                    "ies.js#L34\r\nfloat solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecu" +
                    "larStrength) {\r\n    float specularBrightness = getPerceivedBrightness(specular);" +
                    "\r\n\r\n    if (specularBrightness < c_MinReflectance) {\r\n        return 0.0;\r\n    }" +
                    "\r\n\r\n    float diffuseBrightness = getPerceivedBrightness(diffuse);\r\n\r\n    float " +
                    "a = c_MinReflectance;\r\n    float b = diffuseBrightness * oneMinusSpecularStrengt" +
                    "h / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;\r\n   " +
                    " float c = c_MinReflectance - specularBrightness;\r\n    float D = b * b - 4.0 * a" +
                    " * c;\r\n\r\n    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);\r\n}\r\n\r\nAngularIn" +
                    "fo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)\r\n{\r\n    // Standard" +
                    " one-letter names\r\n    vec3 n = normalize(normal);           // Outward directio" +
                    "n of surface point\r\n    vec3 v = normalize(view);             // Direction from " +
                    "surface point to view\r\n    vec3 l = normalize(pointToLight);     // Direction fr" +
                    "om surface point to light\r\n    vec3 h = normalize(l + v);            // Directio" +
                    "n of the vector between l and v\r\n\r\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);" +
                    "\r\n    float NdotV = clamp(dot(n, v), 0.0, 1.0);\r\n    float NdotH = clamp(dot(n, " +
                    "h), 0.0, 1.0);\r\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\r\n    float VdotH =" +
                    " clamp(dot(v, h), 0.0, 1.0);\r\n\r\n    return AngularInfo(\r\n        NdotL,\r\n       " +
                    " NdotV,\r\n        NdotH,\r\n        LdotH,\r\n        VdotH,\r\n        vec3(0, 0, 0)\r\n" +
                    "    );\r\n}\r\n\r\n// KHR_lights_punctual extension.\r\n// see https://github.com/Khrono" +
                    "sGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n\r\nstruct Lig" +
                    "ht\r\n{\r\n    vec3 direction;\r\n    float range;\r\n\r\n    vec3 color;\r\n    float inten" +
                    "sity;\r\n\r\n    vec3 position;\r\n    float innerConeCos;\r\n\r\n    float outerConeCos;\r" +
                    "\n    int type;\r\n\r\n    vec2 padding;\r\n};\r\n\r\nconst int LightType_Directional = 0;\r" +
                    "\nconst int LightType_Point = 1;\r\nconst int LightType_Spot = 2;\r\n\r\n#ifdef USE_PUN" +
                    "CTUAL\r\nuniform Light u_Lights[LIGHT_COUNT];\r\n#endif\r\n\r\n#ifdef ALPHAMODE_MASK\r\nun" +
                    "iform float u_AlphaCutoff;\r\n#endif\r\n\r\nstruct MaterialInfo\r\n{\r\n    float perceptu" +
                    "alRoughness;    // roughness value, as authored by the model creator (input to s" +
                    "hader)\r\n    vec3 reflectance0;            // full reflectance color (normal inci" +
                    "dence angle)\r\n\r\n    float alphaRoughness;         // roughness mapped to a more " +
                    "linear change in the roughness (proposed by [2])\r\n    vec3 diffuseColor;        " +
                    "    // color contribution from diffuse lighting\r\n\r\n    vec3 reflectance90;      " +
                    "     // reflectance color at grazing angle\r\n    vec3 specularColor;           //" +
                    " color contribution from specular lighting\r\n};\r\n\r\n// Calculation of the lighting" +
                    " contribution from an optional Image Based Light source.\r\n// Precomputed Environ" +
                    "ment Maps are required uniform inputs and are computed as outlined in [1].\r\n// S" +
                    "ee our README.md on Environment Maps [3] for additional discussion.\r\n#ifdef USE_" +
                    "IBL\r\nvec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)\r\n{\r\n    " +
                    "float NdotV = clamp(dot(n, v), 0.0, 1.0);\r\n\r\n    float lod = clamp(materialInfo." +
                    "perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));\r\n    vec3 refl" +
                    "ection = normalize(reflect(-v, n));\r\n\r\n    vec2 brdfSamplePoint = clamp(vec2(Ndo" +
                    "tV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\r\n    // " +
                    "retrieve a scale and bias to F0. See [1], Figure 3\r\n    vec2 brdf = texture(samp" +
                    "ler2D(brdfLUTTexture, brdfLUTSampler), brdfSamplePoint).rg;\r\n\r\n    //vec4 diffus" +
                    "eSample = texture(samplerCube(DiffuseEnvTexture, DiffuseEnvSampler), n);\r\n\tvec4 " +
                    "diffuseSample = textureLod(samplerCube(SpecularEnvTexture, SpecularEnvSampler), " +
                    "n, 6);\r\n\r\n#ifdef USE_TEX_LOD\r\n    vec4 specularSample = textureLod(samplerCube(S" +
                    "pecularEnvTexture, SpecularEnvSampler), reflection, lod);\r\n#else\r\n    vec4 specu" +
                    "larSample = texture(samplerCube(SpecularEnvTexture, SpecularEnvSampler), reflect" +
                    "ion);\r\n#endif\r\n\r\n#ifdef USE_HDR\r\n    // Already linear.\r\n    vec3 diffuseLight =" +
                    " diffuseSample.rgb;\r\n    vec3 specularLight = specularSample.rgb;\r\n#else\r\n    ve" +
                    "c3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;\r\n    vec3 specularLight = SRG" +
                    "BtoLINEAR(specularSample).rgb;\r\n#endif\r\n\r\n    vec3 diffuse = diffuseLight * mate" +
                    "rialInfo.diffuseColor;\r\n    vec3 specular = specularLight * (materialInfo.specul" +
                    "arColor * brdf.x + brdf.y);\r\n\r\n    return diffuse + specular;\r\n}\r\n#endif\r\n\r\n// L" +
                    "ambert lighting\r\n// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to" +
                    "-pi-in-game-lighting-equation/\r\nvec3 diffuse(MaterialInfo materialInfo)\r\n{\r\n    " +
                    "return materialInfo.diffuseColor / M_PI;\r\n}\r\n\r\n// The following equation models " +
                    "the Fresnel reflectance term of the spec equation (aka F())\r\n// Implementation o" +
                    "f fresnel from [4], Equation 15\r\nvec3 specularReflection(MaterialInfo materialIn" +
                    "fo, AngularInfo angularInfo)\r\n{\r\n    return materialInfo.reflectance0 + (materia" +
                    "lInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.V" +
                    "dotH, 0.0, 1.0), 5.0);\r\n}\r\n\r\n// Smith Joint GGX\r\n// Note: Vis = G / (4 * NdotL *" +
                    " NdotV)\r\n// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function i" +
                    "n Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3\r\n// see Rea" +
                    "l-Time Rendering. Page 331 to 336.\r\n// see https://google.github.io/filament/Fil" +
                    "ament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)\r\nfloat v" +
                    "isibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)\r\n{\r\n    f" +
                    "loat NdotL = angularInfo.NdotL;\r\n    float NdotV = angularInfo.NdotV;\r\n    float" +
                    " alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;\r\n" +
                    "\r\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alpha" +
                    "RoughnessSq);\r\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughne" +
                    "ssSq) + alphaRoughnessSq);\r\n\r\n    float GGX = GGXV + GGXL;\r\n    if (GGX > 0.0)\r\n" +
                    "    {\r\n        return 0.5 / GGX;\r\n    }\r\n    return 0.0;\r\n}\r\n\r\n// The following " +
                    "equation(s) model the distribution of microfacet normals across the area being d" +
                    "rawn (aka D())\r\n// Implementation from \"Average Irregularity Representation of a" +
                    " Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\r\n// " +
                    "Follows the distribution function recommended in the SIGGRAPH 2013 course notes " +
                    "from EPIC Games [1], Equation 3.\r\nfloat microfacetDistribution(MaterialInfo mate" +
                    "rialInfo, AngularInfo angularInfo)\r\n{\r\n    float alphaRoughnessSq = materialInfo" +
                    ".alphaRoughness * materialInfo.alphaRoughness;\r\n    float f = (angularInfo.NdotH" +
                    " * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;\r\n    return " +
                    "alphaRoughnessSq / (M_PI * f * f);\r\n}\r\n\r\nvec3 getPointShade(vec3 pointToLight, M" +
                    "aterialInfo materialInfo, vec3 normal, vec3 view)\r\n{\r\n    AngularInfo angularInf" +
                    "o = getAngularInfo(pointToLight, normal, view);\r\n\r\n    if (angularInfo.NdotL > 0" +
                    ".0 || angularInfo.NdotV > 0.0)\r\n    {\r\n        // Calculate the shading terms fo" +
                    "r the microfacet specular shading model\r\n        vec3 F = specularReflection(mat" +
                    "erialInfo, angularInfo);\r\n        float Vis = visibilityOcclusion(materialInfo, " +
                    "angularInfo);\r\n        float D = microfacetDistribution(materialInfo, angularInf" +
                    "o);\r\n\r\n        // Calculation of analytical lighting contribution\r\n        vec3 " +
                    "diffuseContrib = (1.0 - F) * diffuse(materialInfo);\r\n        vec3 specContrib = " +
                    "F * Vis * D;\r\n\r\n        // Obtain final intensity as reflectance (BRDF) scaled b" +
                    "y the energy of the light (cosine law)\r\n        return angularInfo.NdotL * (diff" +
                    "useContrib + specContrib);\r\n    }\r\n\r\n    return vec3(0.0, 0.0, 0.0);\r\n}\r\n\r\n// ht" +
                    "tps://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights" +
                    "_punctual/README.md#range-property\r\nfloat getRangeAttenuation(float range, float" +
                    " distance)\r\n{\r\n    if (range < 0.0)\r\n    {\r\n        // negative range means unli" +
                    "mited\r\n        return 1.0;\r\n    }\r\n    return max(min(1.0 - pow(distance / range" +
                    ", 4.0), 1.0), 0.0) / pow(distance, 2.0);\r\n}\r\n\r\n// https://github.com/KhronosGrou" +
                    "p/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-an" +
                    "d-outer-cone-angles\r\nfloat getSpotAttenuation(vec3 pointToLight, vec3 spotDirect" +
                    "ion, float outerConeCos, float innerConeCos)\r\n{\r\n    float actualCos = dot(norma" +
                    "lize(spotDirection), normalize(-pointToLight));\r\n    if (actualCos > outerConeCo" +
                    "s)\r\n    {\r\n        if (actualCos < innerConeCos)\r\n        {\r\n            return " +
                    "smoothstep(outerConeCos, innerConeCos, actualCos);\r\n        }\r\n        return 1." +
                    "0;\r\n    }\r\n    return 0.0;\r\n}\r\n\r\nvec3 applyDirectionalLight(Light light, Materia" +
                    "lInfo materialInfo, vec3 normal, vec3 view)\r\n{\r\n    vec3 pointToLight = -light.d" +
                    "irection;\r\n    vec3 shade = getPointShade(pointToLight, materialInfo, normal, vi" +
                    "ew);\r\n    return light.intensity * light.color * shade;\r\n}\r\n\r\nvec3 applyPointLig" +
                    "ht(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)\r\n{\r\n    vec3 " +
                    "pointToLight = light.position - v_Position;\r\n    float distance = length(pointTo" +
                    "Light);\r\n    float attenuation = getRangeAttenuation(light.range, distance);\r\n  " +
                    "  vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);\r\n    ret" +
                    "urn attenuation * light.intensity * light.color * shade;\r\n}\r\n\r\nvec3 applySpotLig" +
                    "ht(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)\r\n{\r\n    vec3 " +
                    "pointToLight = light.position - v_Position;\r\n    float distance = length(pointTo" +
                    "Light);\r\n    float rangeAttenuation = getRangeAttenuation(light.range, distance)" +
                    ";\r\n    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction," +
                    " light.outerConeCos, light.innerConeCos);\r\n    vec3 shade = getPointShade(pointT" +
                    "oLight, materialInfo, normal, view);\r\n    return rangeAttenuation * spotAttenuat" +
                    "ion * light.intensity * light.color * shade;\r\n}\r\n\r\nvoid main()\r\n{\r\n    // Metall" +
                    "ic and Roughness material properties are packed together\r\n    // In glTF, these " +
                    "factors can be specified by fixed scalar values\r\n    // or from a metallic-rough" +
                    "ness map\r\n    float perceptualRoughness = 0.0;\r\n    float metallic = 0.0;\r\n    v" +
                    "ec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    vec3 diffuseColor = vec3(0.0);\r\n " +
                    "   vec3 specularColor= vec3(0.0);\r\n    vec3 f0 = vec3(0.04);\r\n\r\n#ifdef MATERIAL_" +
                    "SPECULARGLOSSINESS\r\n\r\n#ifdef HAS_SPECULAR_GLOSSINESS_MAP\r\n    vec4 sgSample = SR" +
                    "GBtoLINEAR(texture(sampler2D(SpecularGlossinessTexture, SpecularGlossinessSample" +
                    "r), getSpecularGlossinessUV()));\r\n    perceptualRoughness = (1.0 - sgSample.a * " +
                    "GlossinessFactor); // glossiness to roughness\r\n    f0 = sgSample.rgb * SpecularF" +
                    "actor; // specular\r\n#else\r\n    f0 = SpecularFactor;\r\n    perceptualRoughness = 1" +
                    ".0 - GlossinessFactor;\r\n#endif // ! HAS_SPECULAR_GLOSSINESS_MAP\r\n\r\n#ifdef HAS_DI" +
                    "FFUSE_MAP\r\n    baseColor = SRGBtoLINEAR(texture(sampler2D(DiffuseTexture, Diffus" +
                    "eSampler), getDiffuseUV())) * DiffuseFactor;\r\n#else\r\n    baseColor = DiffuseFact" +
                    "or;\r\n#endif // !HAS_DIFFUSE_MAP\r\n\r\n    baseColor *= getVertexColor();\r\n\r\n    // " +
                    "f0 = specular\r\n    specularColor = f0;\r\n    float oneMinusSpecularStrength = 1.0" +
                    " - max(max(f0.r, f0.g), f0.b);\r\n    diffuseColor = baseColor.rgb * oneMinusSpecu" +
                    "larStrength;\r\n\r\n#ifdef DEBUG_METALLIC\r\n    // do conversion between metallic M-R" +
                    " and S-G metallic\r\n    metallic = solveMetallic(baseColor.rgb, specularColor, on" +
                    "eMinusSpecularStrength);\r\n#endif // ! DEBUG_METALLIC\r\n\r\n#endif // ! MATERIAL_SPE" +
                    "CULARGLOSSINESS\r\n\r\n#ifdef MATERIAL_METALLICROUGHNESS\r\n\r\n#ifdef HAS_METALLIC_ROUG" +
                    "HNESS_MAP\r\n    // Roughness is stored in the \'g\' channel, metallic is stored in " +
                    "the \'b\' channel.\r\n    // This layout intentionally reserves the \'r\' channel for " +
                    "(optional) occlusion map data\r\n    vec4 mrSample = texture(sampler2D(MetallicRou" +
                    "ghnessTexture, MetallicRoughnessSampler), getMetallicRoughnessUV());\r\n    percep" +
                    "tualRoughness = mrSample.g * RoughnessFactor;\r\n    metallic = mrSample.b * Metal" +
                    "licFactor;\r\n#else\r\n    metallic = MetallicFactor;\r\n    perceptualRoughness = Rou" +
                    "ghnessFactor;\r\n#endif\r\n\r\n    // The albedo may be defined from a base texture or" +
                    " a flat color\r\n#ifdef HAS_BASE_COLOR_MAP\r\n    baseColor = SRGBtoLINEAR(texture(s" +
                    "ampler2D(BaseColorTexture, BaseColorSampler), getBaseColorUV())) * BaseColorFact" +
                    "or;\r\n#else\r\n    baseColor = BaseColorFactor;\r\n#endif\r\n\r\n    baseColor *= getVert" +
                    "exColor();\r\n\r\n    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metal" +
                    "lic);\r\n\r\n    specularColor = mix(f0, baseColor.rgb, metallic);\r\n\r\n#endif // ! MA" +
                    "TERIAL_METALLICROUGHNESS\r\n\r\n#ifdef ALPHAMODE_MASK\r\n    if(baseColor.a < u_AlphaC" +
                    "utoff)\r\n    {\r\n        discard;\r\n    }\r\n    baseColor.a = 1.0;\r\n#endif\r\n\r\n#ifdef" +
                    " ALPHAMODE_OPAQUE\r\n    baseColor.a = 1.0;\r\n#endif\r\n\r\n#ifdef MATERIAL_UNLIT\r\n    " +
                    "outFragColor = vec4(LINEARtoSRGB(baseColor.rgb), baseColor.a);\r\n    return;\r\n#en" +
                    "dif\r\n\r\n    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);\r\n    meta" +
                    "llic = clamp(metallic, 0.0, 1.0);\r\n\r\n    // Roughness is authored as perceptual " +
                    "roughness; as is convention,\r\n    // convert to material roughness by squaring t" +
                    "he perceptual roughness [2].\r\n    float alphaRoughness = perceptualRoughness * p" +
                    "erceptualRoughness;\r\n\r\n    // Compute reflectance.\r\n    float reflectance = max(" +
                    "max(specularColor.r, specularColor.g), specularColor.b);\r\n\r\n    vec3 specularEnv" +
                    "ironmentR0 = specularColor.rgb;\r\n    // Anything less than 2% is physically impo" +
                    "ssible and is instead considered to be shadowing. Compare to \"Real-Time-Renderin" +
                    "g\" 4th editon on page 325.\r\n    vec3 specularEnvironmentR90 = vec3(clamp(reflect" +
                    "ance * 50.0, 0.0, 1.0));\r\n\r\n    MaterialInfo materialInfo = MaterialInfo(\r\n     " +
                    "   perceptualRoughness,\r\n        specularEnvironmentR0,\r\n        alphaRoughness," +
                    "\r\n        diffuseColor,\r\n        specularEnvironmentR90,\r\n        specularColor\r" +
                    "\n    );\r\n\r\n    // LIGHTING\r\n\r\n    vec3 color = vec3(0.0, 0.0, 0.0);\r\n    vec3 no" +
                    "rmal = getNormal();\r\n    vec3 view = normalize(u_Camera - v_Position);\r\n\r\n#ifdef" +
                    " USE_PUNCTUAL\r\n    for (int i = 0; i < LIGHT_COUNT; ++i)\r\n    {\r\n        Light l" +
                    "ight = u_Lights[i];\r\n        if (light.type == LightType_Directional)\r\n        {" +
                    "\r\n            color += applyDirectionalLight(light, materialInfo, normal, view);" +
                    "\r\n        }\r\n        else if (light.type == LightType_Point)\r\n        {\r\n       " +
                    "     color += applyPointLight(light, materialInfo, normal, view);\r\n        }\r\n  " +
                    "      else if (light.type == LightType_Spot)\r\n        {\r\n            color += ap" +
                    "plySpotLight(light, materialInfo, normal, view);\r\n        }\r\n    }\r\n#endif\r\n\r\n  " +
                    "  // Calculate lighting contribution from image based lighting source (IBL)\r\n#if" +
                    "def USE_IBL\r\n    color += getIBLContribution(materialInfo, normal, view);\r\n#endi" +
                    "f\r\n\r\n    float ao = 1.0;\r\n    // Apply optional PBR terms for additional (option" +
                    "al) shading\r\n#ifdef HAS_OCCLUSION_MAP\r\n    ao = texture(sampler2D(OcclusionTextu" +
                    "re, OcclusionSampler), getOcclusionUV()).r;\r\n    color = mix(color, color * ao, " +
                    "u_OcclusionStrength);\r\n#endif\r\n\r\n    vec3 emissive = vec3(0);\r\n#ifdef HAS_EMISSI" +
                    "VE_MAP\r\n    emissive = SRGBtoLINEAR(texture(sampler2D(EmissiveTexture, EmissiveS" +
                    "ampler), getEmissiveUV())).rgb * EmissiveFactor;\r\n    color += emissive;\r\n#endif" +
                    "\r\n\r\n#ifndef DEBUG_OUTPUT // no debug\r\n\r\n   // regular shading\r\n   outFragColor =" +
                    " vec4(toneMap(color), baseColor.a);\r\n\r\n#else // debug output\r\n\r\n    #ifdef DEBUG" +
                    "_METALLIC\r\n        outFragColor.rgb = vec3(metallic);\r\n    #endif\r\n\r\n    #ifdef " +
                    "DEBUG_ROUGHNESS\r\n        outFragColor.rgb = vec3(perceptualRoughness);\r\n    #end" +
                    "if\r\n\r\n    #ifdef DEBUG_NORMAL\r\n        #ifdef HAS_NORMAL_MAP\r\n            outFra" +
                    "gColor.rgb = texture2D(NormalSampler, getNormalUV()).rgb;\r\n        #else\r\n      " +
                    "      outFragColor.rgb = vec3(0.5, 0.5, 1.0);\r\n        #endif\r\n    #endif\r\n\r\n   " +
                    " #ifdef DEBUG_BASECOLOR\r\n        outFragColor.rgb = LINEARtoSRGB(baseColor.rgb);" +
                    "\r\n    #endif\r\n\r\n    #ifdef DEBUG_OCCLUSION\r\n        outFragColor.rgb = vec3(ao);" +
                    "\r\n    #endif\r\n\r\n    #ifdef DEBUG_EMISSIVE\r\n        outFragColor.rgb = LINEARtoSR" +
                    "GB(emissive);\r\n    #endif\r\n\r\n    #ifdef DEBUG_F0\r\n        outFragColor.rgb = vec" +
                    "3(f0);\r\n    #endif\r\n\r\n    #ifdef DEBUG_ALPHA\r\n        outFragColor.rgb = vec3(ba" +
                    "seColor.a);\r\n    #endif\r\n\r\n    outFragColor.a = 1.0;\r\n\r\n#endif // !DEBUG_OUTPUT\r" +
                    "\n}");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public class FragmentShaderBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
